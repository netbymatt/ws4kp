//@version=6
indicator("Minute of Hour Seasonality", overlay = false, max_boxes_count = 500)

//#region ———————————————————— Constants, inputs, and global variables

// Tooltips
string TT_SY = "The year to start seasonality calculations."
string TT_PC = "The base color for boxes and table cells that show positive values."
string TT_NC = "The base color for boxes and table cells that show negative values."
string TT_CP = "The cutoff for maximum color intensity. Absolute values at or above this level have the same color."
string TT_SH = "Start hour for display (0-23)."
string TT_EH = "End hour for display (0-23)."
string TT_BK = "Group minutes into buckets. E.g., 5 means :00-:04, :05-:09, etc."

// Start year setting
int startYearInput = input.int(2020, "Starting year", minval = 1800, tooltip = TT_SY, display = display.none)

// Hour range settings
string HOURS_GRP = "Hour range"
int    startHour = input.int(9, "Start Hour (0-23)", minval = 0, maxval = 23, group = HOURS_GRP, tooltip = TT_SH)
int    endHour   = input.int(16, "End Hour (0-23)", minval = 0, maxval = 23, group = HOURS_GRP, tooltip = TT_EH)

// Minute bucket settings
string MINUTES_GRP = "Minute settings"
int    bucketSize  = input.int(5, "Bucket size (minutes)", minval = 1, maxval = 30, group = MINUTES_GRP, tooltip = TT_BK)

// Color settings
string COLOR_GRP          = "Color settings"
color  posColorInput      = color.new(input.color(#089981, "Positive Color", group = COLOR_GRP, tooltip = TT_PC), 0)
color  negColorInput      = color.new(input.color(#F23745, "Negative Color", group = COLOR_GRP, tooltip = TT_NC), 0)
int    cutoffPercentInput = input.int(1, "Color intensity cutoff (%)", group = COLOR_GRP, tooltip = TT_CP, display = display.none)

// Table settings
string HEATMAP_GRP        = "Heatmap settings"
string tablePositionInput = input.string("Center", "Table Position", options = ["Left", "Center", "Right"], group = HEATMAP_GRP, display = display.none)
float  tableWidthInput    = input.float(100, "Table Width (%)", maxval = 100, minval = 0, group = HEATMAP_GRP, display = display.none)
float  tableHeightInput   = input.float(95, "Table Height (%)", maxval = 100, minval = 0, group = HEATMAP_GRP, display = display.none)
bool   showAvgInput       = input.bool(true, "Show Averages", group = HEATMAP_GRP)
bool   showStDevInput     = input.bool(true, "Show Standard Deviation", group = HEATMAP_GRP)
bool   showPosInput       = input.bool(true, "Show Percent Positive", group = HEATMAP_GRP)
bool   showMetrics        = showAvgInput or showStDevInput or showPosInput

// Calculate dimensions
int numHours   = endHour >= startHour ? endHour - startHour + 1 : (24 - startHour) + endHour + 1
int numBuckets = math.ceil(60 / bucketSize)

//@variable Current time info
int currHour   = hour(time_close - 1)
int currMinute = minute(time_close - 1)

prevTimeClose     = time_close[1] - 1
int prevBarYear   = year(prevTimeClose)
int prevBarHour   = hour(prevTimeClose)
int prevBarMinute = minute(prevTimeClose)
//#endregion


//#region ———————————————————— Functions and methods

//@function Calculates color used by the Heatmap cells.
calcColor(float value, int topTranspValue = na) =>
    color naColor     = color.gray
    float heavyTransp = 50
    float lightTransp = 90
    color heavyColor  = color.new(value >= 0 ? posColorInput : negColorInput, heavyTransp)
    color lightColor  = color.new(value >= 0 ? posColorInput : negColorInput, lightTransp)
    color baseColor   = na(value) ? naColor : value >= 0 ? posColorInput : negColorInput
    color transpColor = color.from_gradient(math.abs(value), 0, topTranspValue, lightColor, heavyColor)
    na(topTranspValue) ? baseColor : transpColor

//@function Returns the one-bar change percentage.
changePercent(float source) => 100.0 * (source - source[1]) / source[1]

//@function Returns the number of non-na values.
method nonNA(array<float> this) =>
    int result = 0
    for item in this
        if not na(item)
            result += 1
    result

//@function Returns the percentage of positive non-na values.
method percentPositive(array<float> this) =>
    int countNonNA = 0
    int pos = 0
    for item in this
        if not na(item)
            countNonNA += 1
            if item >= 0
                pos += 1
    100.0 * pos / countNonNA

//@function Checks if hour is within display range.
isHourInRange(int h, int startH, int endH) =>
    if startH <= endH
        h >= startH and h <= endH
    else
        h >= startH or h <= endH

//@function Converts hour to row index.
hourToRow(int h, int startH, int endH) =>
    if startH <= endH
        h - startH
    else
        if h >= startH
            h - startH
        else
            (24 - startH) + h

//@function Converts minute to bucket index (1-based for columns).
minuteToBucket(int m, int bSize) =>
    math.floor(m / bSize) + 1

//@function Calculates matrix of minute changes aggregated by hour and minute bucket.
//@returns Matrix where rows=hours, cols=0(label)+minute buckets
calculateMinuteChanges(int startYear, int prevBarYear, int prevBarHour, int prevBarMinute, int startH, int endH, int numH, int bSize, int numB) =>
    // Matrix: rows = hours in range, columns = 0 (label) + minute buckets
    var matrix<float> sumMatrix   = matrix.new<float>(numH, numB + 1, 0.0)
    var matrix<int>   countMatrix = matrix.new<int>(numH, numB + 1, 0)

    float prevChange = changePercent(close[1])

    if prevBarYear >= startYear and not na(prevChange) and isHourInRange(prevBarHour, startH, endH)
        int rowIdx = hourToRow(prevBarHour, startH, endH)
        int colIdx = minuteToBucket(prevBarMinute, bSize)

        float oldSum = sumMatrix.get(rowIdx, colIdx)
        int oldCount = countMatrix.get(rowIdx, colIdx)
        sumMatrix.set(rowIdx, colIdx, oldSum + prevChange)
        countMatrix.set(rowIdx, colIdx, oldCount + 1)

    // Build final averaged matrix
    var matrix<float> dataMatrix = matrix.new<float>(numH, numB + 1, na)
    if barstate.islast
        for row = 0 to numH - 1
            for col = 1 to numB
                int cnt = countMatrix.get(row, col)
                if cnt > 0
                    float avg = sumMatrix.get(row, col) / cnt
                    dataMatrix.set(row, col, avg)

    dataMatrix
//#endregion


//#region ———————————————————— Main calculations and outputs

// Request minute data
changesMatrix = request.security(
     syminfo.tickerid, "1", calculateMinuteChanges(startYearInput, prevBarYear, prevBarHour, prevBarMinute, startHour, endHour, numHours, bucketSize, numBuckets),
     lookahead = barmerge.lookahead_on
 )

// Current stats
var float currAverage = na

if barstate.islast and not na(changesMatrix) and isHourInRange(currHour, startHour, endHour)
    int rowIdx = hourToRow(currHour, startHour, endHour)
    int colIdx = minuteToBucket(currMinute, bucketSize)
    currAverage := changesMatrix.get(rowIdx, colIdx)

// Display plots
displayLoc = display.data_window + display.status_line
plot(currAverage, "Historical avg for current hour:minute", color = calcColor(currAverage), display = displayLoc, format = format.percent)

//@function Generates hour labels for rows.
getHourLabels(int startH, int numH) =>
    var labels = array.new<string>(numH)
    int h = startH
    for i = 0 to numH - 1
        labels.set(i, str.tostring(h, "00") + ":00")
        h := (h + 1) % 24
    labels

//@function Generates minute bucket labels for columns.
getMinuteLabels(int bSize, int numB) =>
    var labels = array.new<string>(numB + 1)
    labels.set(0, "Hour")
    for i = 0 to numB - 1
        int startMin = i * bSize
        int endMin   = math.min((i + 1) * bSize - 1, 59)
        string label = bSize == 1 ? ":" + str.tostring(startMin, "00") : ":" + str.tostring(startMin, "00") + "-:" + str.tostring(endMin, "00")
        labels.set(i + 1, label)
    labels

//@function Calculates total rows for the heatmap.
countRows(int numH, bool showMetrics, bool showAvgInput, bool showStDevInput, bool showPosInput) =>
    int total = 1 + numH  // header + hour rows
    if showMetrics
        total += 1
        total += showAvgInput ? 1 : 0
        total += showStDevInput ? 1 : 0
        total += showPosInput ? 1 : 0
    total


// Heatmap rendering
if barstate.islast and not na(changesMatrix)

    tablePosition = switch tablePositionInput
        "Left"   => position.bottom_left
        "Center" => position.bottom_center
        "Right"  => position.bottom_right

    int numCols = numBuckets + 1
    table dataTable = table.new(tablePosition, numCols, numHours + 5)
    color infoBgColor = color.new(color.gray, 80)
    color textColor   = chart.fg_color
    int totalRows     = countRows(numHours, showMetrics, showAvgInput, showStDevInput, showPosInput)
    float cellHeight  = tableHeightInput / totalRows
    float cellWidth   = tableWidthInput / numCols

    // Header row with minute bucket labels
    var minuteLabels = getMinuteLabels(bucketSize, numBuckets)
    for [i, label] in minuteLabels
        dataTable.cell(i, 0, label, bgcolor = infoBgColor, text_color = textColor, height = cellHeight, width = cellWidth)

    // Data rows (one per hour)
    var hourLabels = getHourLabels(startHour, numHours)
    for row = 0 to numHours - 1
        // Hour label
        dataTable.cell(0, row + 1, hourLabels.get(row), bgcolor = infoBgColor, text_color = textColor, height = cellHeight, width = cellWidth)
        // Minute bucket values
        for col = 1 to numBuckets
            float val = changesMatrix.get(row, col)
            string txt = na(val) ? "-" : str.tostring(val, format.percent)
            color clr = na(val) ? color.new(color.gray, 80) : calcColor(val, cutoffPercentInput)
            dataTable.cell(col, row + 1, txt, bgcolor = clr, text_color = textColor, height = cellHeight, width = cellWidth)

    // Metrics rows
    if showMetrics
        int divRow = numHours + 1
        dataTable.cell(0, divRow, "", bgcolor = infoBgColor, text_size = size.tiny, height = cellHeight, width = cellWidth)
        dataTable.merge_cells(0, divRow, numCols - 1, divRow)

        if showAvgInput
            int avgRow = numHours + 2
            dataTable.cell(0, avgRow, "Avgs:", bgcolor = infoBgColor, text_color = textColor, height = cellHeight, width = cellWidth)
            for col = 1 to numBuckets
                float avg = changesMatrix.col(col).avg()
                dataTable.cell(col, avgRow, str.tostring(avg, format.percent), bgcolor = calcColor(avg, cutoffPercentInput), text_color = textColor, height = cellHeight, width = cellWidth)

        if showStDevInput
            int sdRow = numHours + 3
            dataTable.cell(0, sdRow, "StDev:", bgcolor = infoBgColor, text_color = textColor, height = cellHeight, width = cellWidth)
            for col = 1 to numBuckets
                float sd = changesMatrix.col(col).stdev(false)
                dataTable.cell(col, sdRow, str.tostring(sd, "##.##"), bgcolor = color.new(color.gray, 80), text_color = textColor, height = cellHeight, width = cellWidth)

        if showPosInput
            int posRow = numHours + 4
            dataTable.cell(0, posRow, "Pos%:", bgcolor = infoBgColor, text_color = textColor, height = cellHeight, width = cellWidth)
            for col = 1 to numBuckets
                float pct = changesMatrix.col(col).percentPositive()
                dataTable.cell(col, posRow, str.tostring(pct, '#') + "%", bgcolor = calcColor(pct - 50, 50), text_color = textColor, height = cellHeight, width = cellWidth)
//#endregion
